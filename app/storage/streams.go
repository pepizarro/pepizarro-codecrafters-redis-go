package storage

import (
	"fmt"
	"regexp"
	"strconv"
)

type Entry struct {
	id     string
	values map[string][]byte
}

type Stream struct {
	entries []Entry
}

func (k *KeySpace) NewEntry(id string, values map[string][]byte) Entry {
	return Entry{
		id:     id,
		values: values,
	}
}

func (k *KeySpace) SetStream(key string, entry Entry) (error, string) {
	k.mu.Lock()
	defer k.mu.Unlock()
	i, exists := k.keyspace[key]
	if exists && i.valueType != STREAM {
		return fmt.Errorf("Key %s already exists and is not a stream", key), ""
	}

	if exists {
		// add entry to the stream
		err, entryID := k.validateEntryID(i.value.(Stream), entry.id)
		if err != nil {
			return err, ""
		}
		fmt.Println("Adding entry to stream")

		entry.id = entryID
		streamEntries := i.value.(Stream).entries
		streamEntries = append(streamEntries, entry)
		k.keyspace[key] = item{value: Stream{entries: streamEntries}, valueType: STREAM}

		return nil, entryID
	}

	// err, ms, seq := parseEntryId(entry.id)
	// if err != nil {
	// 	return err, ""
	// }
	//
	// entry.id = fmt.Sprintf("%d-%d", ms, seq)
	//
	// stream := Stream{
	// 	entries: []Entry{entry},
	// }
	//
	// k.keyspace[key] = item{value: stream, valueType: STREAM}

	return nil, entry.id
}

func (k *KeySpace) GetStream(key string) (Stream, error) {
	k.mu.RLock()
	defer k.mu.RUnlock()

	i, exists := k.keyspace[key]
	if !exists {
		return Stream{}, fmt.Errorf("Key not found: %s", key)
	}

	if i.valueType != STREAM {
		return Stream{}, fmt.Errorf("Invalid type: %s", i.valueType)
	}

	return i.value.(Stream), nil
}

func (k *KeySpace) validateEntryID(stream Stream, id string) (error, string) {
	// check id format n-n
	// err, matches := parseEntryId(id)
	// if err != nil {
	// 	return err, ""
	// }
	//
	// // // check if id is 0-0
	// // if milliseconds == 0 && sequence == 0 {
	// // 	return fmt.Errorf("ERR The ID specified in XADD must be greater than 0-0"), ""
	// // }
	//
	// // handle n-* and no entries case
	// if sequence == "*" && len(stream.entries) == 0 {
	// 	return nil, fmt.Sprintf("%d-%s", milliseconds, 1)
	// }
	//
	// // compare with last entry
	// // if len(stream.entries) == 0 {
	// // 	return nil, fmt.Sprintf("%d-%s", milliseconds, sequence)
	// // }
	//
	// lastEntry := stream.entries[len(stream.entries)-1]
	// err, lastMilliseconds, lastSequence := parseEntryId(lastEntry.id)
	// if err != nil {
	// 	return err, ""
	// }
	//
	// if milliseconds < lastMilliseconds {
	// 	return fmt.Errorf("ERR The ID specified in XADD is equal or smaller than the target stream top item"), ""
	// }
	//
	// if milliseconds == lastMilliseconds && sequence <= lastSequence {
	// 	return fmt.Errorf("ERR The ID specified in XADD is equal or smaller than the target stream top item"), ""
	// }
	//
	// return nil, fmt.Sprintf("%d-%d", milliseconds, sequence+1)
	return nil, ""
}

func (k *KeySpace) SetEntryWithAutoGeneratedID(key string, entry Entry) (string, error) {
	fmt.Println("Setting entry with WithAutoGeneratedID")

	return "", nil
}

func (k *KeySpace) SetEntryWithAutoGeneratedSequence(key string, ms string, entry Entry) (string, error) {
	fmt.Println("Setting entry with WithAutoGeneratedSequence")

	k.mu.Lock()
	defer k.mu.Unlock()
	i, exists := k.keyspace[key]
	if exists && i.valueType != STREAM {
		return "", fmt.Errorf("Key %s already exists and is not a stream", key)
	}

	if exists {
		// add entry to the stream
		lastSeq, err := validateMilliseconds(i.value.(Stream), ms)
		if err != nil {
			return "", err
		}
		fmt.Println("Adding entry to stream")

		entryID := fmt.Sprintf("%s-%d", ms, lastSeq+1)
		entry.id = entryID
		streamEntries := i.value.(Stream).entries
		streamEntries = append(streamEntries, entry)
		k.keyspace[key] = item{value: Stream{entries: streamEntries}, valueType: STREAM}

		return entryID, nil
	}

	entryID := fmt.Sprintf("%s-%d", ms, 1)
	entry.id = entryID
	k.keyspace[key] = item{value: Stream{entries: []Entry{entry}}, valueType: STREAM}

	return entry.id, nil
}

func (k *KeySpace) SetEntryWithID(key string, id string, entry Entry) (string, error) {
	fmt.Println("Setting entry with WithID")

	i, exists := k.keyspace[key]
	if exists && i.valueType != STREAM {
		return "", fmt.Errorf("Key %s already exists and is not a stream", key)
	}

	if exists {
		// add entry to the stream
		ms, lastSeq, err := validateId(i.value.(Stream), id)
		if err != nil {
			return "", err
		}
		fmt.Println("Adding entry to stream")

		entryID := fmt.Sprintf("%d-%d", ms, lastSeq+1)
		entry.id = entryID
		streamEntries := i.value.(Stream).entries
		streamEntries = append(streamEntries, entry)
		k.keyspace[key] = item{value: Stream{entries: streamEntries}, valueType: STREAM}

		return entryID, nil
	}

	entry.id = id
	k.keyspace[key] = item{value: Stream{entries: []Entry{entry}}, valueType: STREAM}

	return entry.id, nil
}

func validateId(stream Stream, id string) (int, int, error) {

	// get the last entry
	lastEntry := stream.entries[len(stream.entries)-1]
	err, lastMs, lastSeq := parseEntryId(lastEntry.id)
	if err != nil {
		return 0, 0, err
	}

	err, ms, seq := parseEntryId(id)
	if err != nil {
		return 0, 0, err
	}

	if ms < lastMs {
		return 0, 0, fmt.Errorf("ERR The ID specified in XADD is equal or smaller than the target stream top item")
	}

	if ms == lastMs && seq <= lastSeq {
		return 0, 0, fmt.Errorf("ERR The ID specified in XADD is equal or smaller than the target stream top item")
	}

	return ms, lastSeq, nil
}

func validateMilliseconds(stream Stream, ms string) (int, error) {

	// get the last entry
	lastEntry := stream.entries[len(stream.entries)-1]
	err, lastMs, lastSeq := parseEntryId(lastEntry.id)
	if err != nil {
		return 0, err
	}

	msInt, err := strconv.Atoi(ms)
	if err != nil {
		return 0, err
	}

	if msInt < lastMs {
		return 0, fmt.Errorf("ERR The ID specified in XADD is equal or smaller than the target stream top item")
	}

	if msInt == lastMs {
		return lastSeq, nil
	}

	return -1, nil
}

func parseEntryId(id string) (error, int, int) {

	r, _ := regexp.Compile(`(\d+)-(\d+)`)
	matches := r.FindStringSubmatch(id)
	if matches == nil {
		return fmt.Errorf("Invalid entry ID format"), 0, 0
	}

	ms, err := strconv.Atoi(matches[1])
	if err != nil {
		return err, 0, 0
	}

	seq, err := strconv.Atoi(matches[2])
	if err != nil {
		return err, 0, 0
	}

	return nil, ms, seq
}
